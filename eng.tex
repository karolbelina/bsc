\documentclass[english,engineering]{wizthesis}

\usepackage[utf8]{inputenc}
\usepackage{float} % H float positioning
\usepackage{xcolor}
\usepackage{enumitem} % enumerate
\usepackage{amsmath, bm}
\usepackage{mathtools}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{wrapfig}
\usepackage{tikz}
\usepackage{tikz-uml}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{array} % \raggedright, \arraybackslash

% Set up the thesis
\author{Karol Belina}
\title{Formal grammar\par production rule parsing tool}
\supervisor{dr inż. Zdzisław Spławski}
\fieldofstudy{Computer Science}
\keywords{Parser combinators, context-free grammars, Extended Backus-Naur Form}
\summary{The thesis documents the process of designing and implementing a tool
for parsing the production rules of context-free grammars in a textual form. It
discusses the choice of Extended Backus-Naur Form notation over the alternatives
and provides a mathematical model for parsing such a notation. The implemented
parser can turn a high-level specification of a grammar into a parser itself,
which in turn is capable of constructing a parse tree from arbitrary input
provided to the program with the use of parser combinators.}

% Set up the bibliography style
\bibliographystyle{acm}
% Set up the column types
\newcolumntype{L}[1]{%
  >{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}p{#1}%
}

\newcommand{\todo}[1]{%
  \textcolor{red}{[\textbf{TODO}\ifx&#1&{}\else{ }\fi\emph{#1}]}%
}

\begin{document}

\frontmatter % Disable page and chapter numbering for this section

\maketitle

% '\chapter*' removes both abstracts from the table of contents
\chapter*{Abstract}

The thesis presents the design and implementation of a context-free grammar
parsing tool with real-time explanations and error detection. It discusses the
choice of Extended Backus-Naur Form notation over the alternatives and provides
a mathematical model for parsing such a notation. For this purpose, the official
specification of the EBNF from the ISO/IEC 14977 standard has been examined and
transformed into an unambiguous form. A definition of a grammar is proposed to
act as a result of the syntactic analysis phase formed with a technique called
\emph{parser combination}. A method of testing an arbitrary input against the
language generated by the constructed grammar is described. The thesis shows the
process of creating a simple command line REPL program to act as a basic tool
for interfacing with the grammar parser and checker, but in order to efficiently
use the library, a web-based application is designed on top of that to serve as
a more visual, user-friendly and easily accessible tool. It describes the
deployment of the application on a static site hosting service, as well as a
cross-platform desktop application. The designed and implemented system gives
the opportunity to extend it with other grammar specifications.

{\let\clearpage\relax % Keep the polish abstract on the same page
\chapter*{Streszczenie}

Praca przedstawia proces projektowania i~implementacji narzędzia służącego~do
analizy~syntaktycznej gramatyk~bezkontekstowych z~naciskiem na~obsługę błędów
i~wyjaśnień w czasie rzeczywistym. Omawia wybór rozszerzonej~notacji
Backusa-Naura i~przestawia matematyczny model do~analizy takiej notacji. W~tym
celu przeprowadzono analizę i~przekształcenie w jednoznaczną formę oficjalnej
jej specyfikacji zdefiniowanej w standardzie ISO/IEC~14977. Zaproponowana
zostaje definicja gramatyki tej notacji, która jest tworzona w wyniku analizy
syntaktycznej za pomocą techniki zwanej \emph{kombinacją~parserów}. Opisana
zostaje metoda sprawdzania dowolnego ciągu znaków pod kątem języka generowanego
przez analizowaną gramatykę. Praca przedstawia stworzenie prostego programu
działającego z~poziomu wiersza poleceń, który jest podstawowym narzędziem do
analizy gramatyk, jednak by móc efektywnie korzystać ze~stworzonej biblioteki,
zaprojektowana zostaje aplikacja webowa, która służy za bardziej wizualne,
przyjazne i łatwo dostępne dla użytkownika narzędzie. Praca opisuje wdrażanie
aplikacji na~usługę hostingową dla statycznych stron, a~także jako
wieloplatformowej aplikacji. Zaprojektowany i~wdrożony system daje możliwość
rozszerzenia go o~inne specyfikacje gramatyk.}

\tableofcontents

\mainmatter % Re-enable page and chapter numbering

\chapter{Problem analysis}

\section{Description and motivation} \label{sec:description-and-motivation}

Programming language theory has become a well-recognized branch of computer
science that deals with the study of programming languages and their
characteristics. It is an active research field, with findings published in
various journals, as well as general publications in computer science and
engineering. But besides the formal nature of Programming language theory, many
amateur programming language creators try their hand at the challenge of
creating a programming language of their own as a personal project. It is
certainly relevant for a person to write their own language for educational
purposes, and to learn about programming language and compiler design. However,
the language creator must first of all make some fundamental decisions about the
paradigms to be used, as well as the syntax of the language.

The tools for aiding the design and implementation of the syntax of a language
are generally called \emph{compiler-compilers}. These programs create parsers,
interpreters or compilers from some formal description of a programming
language (usually a grammar). The most commonly used types of
compiler-compilers are \emph{parser generators}, which handle only the
syntactic analysis of the language --- they do not handle the semantic analysis,
nor the code generation aspect. The parser generators most generally transform a
grammar of the syntax of a given programming language into a source code of a
parser for that language. The language of the source code for such a parser is
dependent on the parser generator.

Most such tools, however, \todo{offer} too much complexity and generally have a steep
learning curve for people inexperienced with the topic. Limited availability
makes them less fitted for prototyping a syntax of a language --- they often
require a complex setup for simple tasks, which is not welcoming for new users
\todo{and may lead to...?}. The lack of visualization capabilities shipped with
these tools makes them less desirable for teachers in the theory of formal
languages, who often require such features for educative purposes in order to
present the formulations of context-free grammars in a more visual format.

\section{Goal of the thesis}

The main goal of this thesis is to design and implement a specialized tool, that
serves teachers, programmers and other kinds of enthusiasts of the theory of
formal languages in the field of discrete mathematics and computer science, in
order to formulate and visualize context-free grammars in the form of the
Extended Backus-Naur Form. In order to \todo{}, the tool must provide a
graphical user interface. Additionally, to ensure the hightest degree of
accessibility, the tool must be available in the form of an easily accessible
web-based application that is accessed through a web page and can run in a
browser without the need of installation on the user's device. The thesis itself
will document the entire process of creating such a project.

\todo{jak projekt pomoże w powyższych problemach?}

In order to achieve the general goal, several sub-goals have been
distinguished, all of which contribute to the main objective as a whole
\begin{itemize}
  \item analysis of existing solutions and applications,
  \item presentation of the theoretical preliminaries of the project,
  \item definition of the outline of the project, including a description of
  the functional and non-functional requirements, the use case diagram, use case
  scenarios, the class diagram, and the user interface prototype,
  \item description of technologies used in the implementation,
  \item implementation of the project,
  \item description of the testing and deployment environments.
\end{itemize}

\section{Scope of the project}

The thesis will propose a definition of a grammar in the form of an abstract
syntax tree of the Extended Backus-Naur Form. It will describe the process of
implementing the business logic of the application in the Rust programming
language compiled to WebAssembly. The compiled code is then ran inside the
web-based application made with the Svelte framework, which incorporates the
markup, CSS styles, and JavaScript scripts in the superset of the HyperText
Markup Language (HTML).

The implementation phase will include the process of tokenization --- the act of
dividing the grammar in a textual form into a sequence of tokens --- while
taking into account proper interpretation of Unicode graphemes. The
whitespace-agnostic tokens will be then combined together to form a
previously-defined abstract syntax tree with a technique called \emph{parser
combination}. Several smaller helper parsers will be defined, all of which then
will be combined into more sophisticated parsers capable of parsing entire
terms, productions, and grammars. The implementation phase will also include the
definition of an algorithm for handling left recursion in the resulting grammar,
as well as a dependency graph reduction algorithm for determining the starting
rule of a grammar. Up to this stage, any errors encountered in the textual form
of a grammar are going to be reported to the user in a friendly format with
exact locations of the errors in the input.

\todo{\begin{itemize}[noitemsep,nolistsep]
  \item service workers
  \item wizualizacje, edytor tekstowy i kolorowanie składni
  \item wyjaśnienia zwracane przez checker?
  \item wyrażenia regularne w specjalnych sekwencjach?
\end{itemize}}

The web application will be deployed on the GitHub Pages hosting service for
static sites, as well as a standalone desktop application with the use of the
Electron framework.

\section{Glossary}

\begin{description}[leftmargin=!,labelwidth=2cm]
  \item[AST] Abstract syntax tree --- \todo{},
  \item[EBNF] Extended Backus-Naur Form --- \todo{},
  \item[parser] \todo{},
  \item[REPL] Read-Eval-Print loop --- \todo{}.
  \item \todo{}
\end{description}

\chapter{Theoretical preliminaries}

\section{Formal grammars}

\subsection{Introduction to formal grammars}

\emph{Formal grammar} of a language defines the construction of strings of
symbols from the language's \emph{alphabet} according to the language's
\emph{syntax}. It is a set of so-called \emph{production~rules} for
rewriting certain strings of symbols with other strings of symbols --- it can
therefore generate any string belonging to that language by repeatedly applying
these rules to a given starting symbol~\cite{meduna-2014}. Furthermore, a
grammar can also be applied in reverse: it can be determined if a string of
symbols belongs to a given language by breaking it down into its constituents
and analyzing them in the process known as \emph{parsing}.

For now, let's consider a simple example of a formal grammar. It consists of two
sets of symbols: (1) set $N = \{\,S, B\,\}$, whose symbols are
\emph{non-terminal} and must be rewritten into other, possibly non-terminal,
symbols, and (2) set $\Sigma = \{\,a, b, c\,\}$, whose symbols are
\emph{terminal} and cannot be rewritten further. Let $S$ be the start symbol
and set $P$ be the set of the following production rules:
\begin{enumerate}[noitemsep]
  \item $S \rightarrow aBSc$
  \item $S \rightarrow abc$
  \item $Ba \rightarrow aB$
  \item $Bb \rightarrow bb$
\end{enumerate}
To generate a string in this language, one must apply these rules (starting with
the start symbol) until a string consisting only of terminal symbols is
produced. A production rule is applied to a string by replacing an occurrence
of the production rule's left-hand side in the string by that production rule's
right-hand side. The simplest example of generating such a string would be
\begin{equation*}
  S \xRightarrow[2]{} \underline{abc}
\end{equation*}
where $P \xRightarrow[i]{} Q$ means that string $P$ generates the string $Q$
according to the production rule $i$, and the generated part of the string
is underlined.

By choosing a different sequence of production rules we can generate a different
string in that language
\begin{equation*}
\begin{split}
  S & \xRightarrow[1]{} \underline{aBSc} \\
    & \xRightarrow[2]{} aB\underline{abc}c \\
    & \xRightarrow[3]{} a\underline{aB}bcc \\
    & \xRightarrow[4]{} aa\underline{bb}cc
\end{split}
\end{equation*}

After examining further examples of strings generated by these production rules
we may come into a conclusion that this grammar generates the language
$\{\,a^nb^nc^n \mid n \ge 1\,\}$, where $x^n$ is a string of $n$ consecutive $x$'s.
It means that the language is the set of strings consisting of one or more
$a$'s, followed by the exact same number of $b$'s, then followed by the exact
same number of $c$'s.

Such a system provides us with a notation for describing a given
language formally. Such a language is a usually infinite set of finite-length
sequences of terminal symbols from that language.

\subsection{The Chomsky Hierarchy}

\begin{wrapfigure}{R}{0.45\textwidth}
  \centering
  \begin{tikzpicture}[scale=2.5]
    \draw[color=black](0,0) ellipse (1.25 and 1)
      node at (0, 0.68) {\small recursively enumerable};
    \draw[color=black](0,-0.2) ellipse (1 and 0.75)
      node at (0, 0.25) {\small context-sensitive};
    \draw[color=black](0,-0.4) ellipse (0.75 and 0.5)
      node at (0, -0.15) {\small context-free};
    \draw[color=black](0,-0.6) ellipse (0.5 and 0.25)
      node {\small regular};
  \end{tikzpicture}
  \caption{The~Chomsky~Hierarchy visualized}
  \label{fig:chomsky-hierarchy}
\end{wrapfigure}

In~\cite{chomsky-1956} Chomsky divides formal grammars into four classes and
classifies them in the now called \emph{Chomsky~Hierarchy}. Each class is a
subset of another, distinguished by the complexity.

Type-3 grammars generate the so-called \emph{regular~languages}. As described
in~\cite{aho-1990}, regular languages can be matched by
\emph{regular~expressions} and decided by a \emph{finite~state~automaton}.
They are the most restricting kinds of grammars, with its production rules
consisting of a single non-terminal on the left-hand side and a single terminal,
possibly followed by a single non-terminal on the right-hand side. Because of
their simplicity, regular languages are used for lexical analysis of programming
languages~\cite{johnson-1968}.

Type-2 grammars produce \emph{context-free~languages} and can be represented
as a \emph{pushdown~automaton} which is an automaton that can maintain its
state with the use of a stack. \todo{jak w stosie wygląda pamięć}

\subsection{Parsing Expression Grammars}

\todo{\url{https://en.wikipedia.org/wiki/Parsing_expression_grammar}}

\todo{\cite{ford-2004}}

\section{Why EBNF?}

\todo{}

\section{Modifying the specification}

\todo{analiza i zmodyfikowanie oficjalnej specyfikacji EBNF}

See appendix \ref{ch:modified-spec}.

\section{Methods of syntactic analysis} \label{sec:parsing}

\subsection{Bottom-up parsing}

\todo{}

\subsection{Top-down parsing and parser combination}

\todo{opisanie parser combinatorów (w Haskellu?) \cite{swierstra-2009}
\cite{leijen-2001} \cite{fokker-1995}}

\begin{minted}{haskell}
type Parser a = String -> Maybe (a, String)
\end{minted}

% \begin{minted}{haskell}
% parse digit "123"
% -- Just ('1', "23")
% \end{minted}

% \begin{minted}{haskell}
% parse (char 'a') "bcd"
% -- Nothing
% \end{minted}

% \begin{minted}{haskell}
% parse (multiple (digit <|> letter)) "abc123"
% -- Just ("abc123", "")
% \end{minted}

\chapter{Analysis of similar solutions}

\section*{Coco/R}

\todo{\cite{coco/r}}

\section*{ANTLR}

\todo{\cite{antlr}}

\section*{Bison}

\todo{\cite{bison}}

\section*{PLY}

\todo{\cite{ply}}

\section*{Regex101}

\todo{\cite{regex101}}

\chapter{Design of the project}

\section{Requirements}

\subsection{Functional requirements}

\begin{table}[H]
  \centering
  \caption{The functional requirements of the project, their features, and
  priorities}
  \label{tab:functional-requirements}
  \begin{tabularx}{\textwidth}{@{}lL{3cm}Xl@{}}
    \toprule
    Id & Requirement & Features & Priority \\
    \midrule
    \emph{R1} & Specifying the grammar & The user can specify the grammar of a
    given language in the EBNF notation by providing it in a textual form in
    a designated editor window. & high \\
    \addlinespace[0.5em] \emph{R2} & Error reporting & The editor provides
    feedback about any syntactic or semantic errors encountered during the
    parsing by highlighting the exact location of the error in the provided
    grammar. The user can then hover the mouse pointer over the highlighted area
    to read the error message. & high \\
    \addlinespace[0.5em] \emph{R3} & Specifying the input string & The user can
    specify the input string in a designated editor window to check if it
    belongs to the language generated by the previously-defined grammar. & high
    \\
    \addlinespace[0.5em] \emph{R4} & Visualizing the parse tree & The
    application visualizes the parse tree resulting from parsing the specified
    input string with the parser generated by the grammar defined by the user. &
    high \\
    \addlinespace[0.5em] \emph{R5} & Syntax highlighting & The editor highlights
    parts of the specified grammar with a different syntactic meaning in a
    different manner with the use of multi-colored fonts. & medium \\
    \addlinespace[0.5em] \emph{R6} & Autocompletion of non-terminals & The
    editor predicts the identifier of a non-terminal a user is typing by
    providing a list of possible non-terminals, which then can be chosen by the
    user. & low \\
    \addlinespace[0.5em] \emph{R7} & Production rule folding & The editor
    provides the ability to hide and reveal a production rule of the grammar
    inside the editor window. & low \\
    \addlinespace[0.5em] \emph{R8} & Search and replace interface & The user can
    search for any occurrences of a phrase in the editor window and possibly
    replace them with a different phrase. The search and replace functionality
    should also support regular expressions. & low \\
    \bottomrule
  \end{tabularx}
\end{table}

\subsection{Non-functional requirements}

\begin{table}[H]
  \centering
  \caption{The non-functional requirements of the project and their priorities}
  \label{tab:non-functional-requirements}
  \begin{tabularx}{\textwidth}{@{}Xl@{}}
    \toprule
    Requirement & Priority \\
    \midrule
    The web application should be available 24 hours a day, 7 days a week. &
    medium \\
    \addlinespace[0.5em] Page loading time should be less than 1 second with
    internet download speed of 80\,Mbps. Parsing and checking times should both
    be less than 50 milliseconds. & high \\
    \addlinespace[0.5em] The application must work and display correctly in
    \begin{itemize}[noitemsep,nolistsep]
      \item Chrome version 86 or later,
      \item Safari version 14 or later,
      \item Edge version 86 or later,
      \item Firefox version 82 or later,
      \item Opera version 71 or later, \end{itemize} as well as in the Electron
    framework version v10.1.5. & high \\
    \addlinespace[0.5em] Usability \todo{} % This focuses on the appearance of
    % the user interface and how people interact with it. What colour are the
    % screens? How big are the buttons?
    & medium \\
    \addlinespace[0.5em] The source code of the product should be open source
    and freely available for possible modification and redistribution. & high \\
    \addlinespace[0.5em] The project should include the documentation necessary
    for extension and maintenance of the system. & high \\
    \addlinespace[0.5em] The system should provide high degree of integrability
    with future components which extend the functionalities of the system. &
    high \\
    \bottomrule
  \end{tabularx}
\end{table}

\section{User stories}

\begin{description}[align=left,leftmargin=4em,style=multiline]
  \item[US1] As the user, I want to be able to paste the contents of my
  clipboard into the editor window in the application.
  \item[US2] As the user, I want to be able to type in the editor window with
  my keyboard.
  \item[US3] As the user, I want to be able to appreciate the multi-colored
  appearance of the text that represents the syntax that I provided.
  \item[US4] As the user, I want to be able to select a portion of the text in
  the editor window and copy it to the clipboard using a keyboard shortcut.
  \item[US5] As the user, I want to be able to hold the \emph{Alt} key on my
  keyboard to create multiple cursors in the editor window.
  \item[US6] As the user, I want to have the ability to autocomplete the
  non-terminal I am typing that has already been declared elsewhere in the code.
  \item[US7] As the user, I want to be able to hide any existing production
  rules that might appear too long, to increase the degree of clarity and
  readability of the grammar I'm working on.
  \item[US8] As the user, I want to be able to show any previously hidden
  production rules of the grammar.
  \item[US9] As the user, I want to have the ability to press a certain key
  combination on my keyboard that would allow be to type a specific phrase
  in the popup window, which would then find all the occurrences of that phrase
  in the editor window.
  \item[US10] As the user, I want to be able to provide a regular expression
  for the \emph{find} functionality that would allow me to find all occurences
  of phrases that pattern match that specific regular expression. 
  \item[US11] As the user, I want to be able to replace some of the occurences
  of phrases found with the \emph{find} functionality with another phrase
  provided in a popup window.
  \item[US12] As the user, I want to be able to see errors in the syntax of the
  provided grammar in the form of underlined text in the location of where the
  errors actually occur.
  \item[US13] As the user, I want to have the ability to hover the mouse pointer
  over the underlined text to read the error message at that location.
  Alternatively, I want to be able to hover over the error indicator, which
  appears next to the line number.
  \item[US14] As the user, I want to be able to see the parse tree of the
  recognized input string that I provided.
  \item[US15] As the user, I want to have the ability to collapse any nodes in
  the visualized parse tree that might appear too long.
\end{description}

% \begin{table}[H]
%   \centering
%   \caption{The user stories}
%   \label{tab:user-stories}
%   \begin{tabularx}{\textwidth}{@{}lX@{}}
%     \toprule
%     Id & User story \\
%     \midrule
%     \emph{US1} & \todo{} \\
%     \emph{US2} & \todo{} \\
%     \emph{US3} & \todo{} \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

\section{Use case specification}

\subsection{Use cases}

\todo{diagram UML przypadków użycia}

\begin{figure}[H]
  \centering

  \begin{tikzpicture}
    \tikzumlset{fill usecase=white}
    \begin{umlsystem}{System}

      \umlusecase[x=0,y=0,width=1.5cm]{\todo{}}
    \end{umlsystem}

    \umlactor[x=-4,y=0]{User}

    \umlassoc{User}{usecase-1}
  \end{tikzpicture}
  \caption{The use case diagram}
  \label{fig:use-case-diagram}
\end{figure}

\todo{opisy przypadków użycia}

% \begin{table}[H]
%   \centering
%   \caption{Descriptions of the use cases}
%   \label{tab:use-cases}
%   \begin{tabularx}{\textwidth}{@{}lX@{}}
%     \toprule
%     Id & User story \\
%     \midrule
%     \emph{UC1} & \todo{} \\
%     \emph{UC2} & \todo{} \\
%     \emph{UC3} & \todo{} \\
%     \bottomrule
%   \end{tabularx}
% \end{table}

\todo{requirements traceability graph --- jak łączą się wymagania z historyjkami
z przypadkami użycia}

% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}[xscale=4,yscale=1.2]
%     \tikzstyle{every node}=[draw,circle,minimum size=1cm,inner sep=0pt]

%     \node at (-1,1)  (uc1) {\emph{UC1}};
%     \node at (-1,0)  (uc2) {\emph{UC2}};
%     \node at (-1,-1) (uc3) {\emph{UC3}};

%     \node at (0,2)  (us1) {\emph{US1}};
%     \node at (0,1)  (us2) {\emph{US2}};
%     \node at (0,0)  (us3) {\emph{US3}};
%     \node at (0,-1) (us4) {\emph{US4}};
%     \node at (0,-2) (us5) {\emph{US5}};

%     \node at (1,1.5)  (r1) {\emph{R1}};
%     \node at (1,0.5)  (r2) {\emph{R2}};
%     \node at (1,-0.5) (r3) {\emph{R3}};
%     \node at (1,-1.5) (r4) {\emph{R4}};

%     \draw (us1) -- (uc1);
%     \draw (us2) -- (uc1);
%     \draw (us3) -- (uc2);
%     \draw (us3) -- (uc3);
%     \draw (us4) -- (uc2);
%     \draw (us5) -- (uc3);

%     \draw (r1) -- (us1);
%     \draw (r1) -- (us2);
%     \draw (r2) -- (us3);
%     \draw (r3) -- (us4);
%     \draw (r4) -- (us5);
%   \end{tikzpicture}
%   \caption{The requirements traceability graph}
%   \label{fig:rtg}
% \end{figure}

\subsection{Use case scenarios}

\todo{opisy scenariuszy przypadków użycia}

% \begin{description}[align=left,leftmargin=3cm,style=multiline]
%   \item [Identifier] \emph{UC1}
%   \item [Title] Proponowanie odcinków
%   \item [Summary] Pozwala przodownikowi na zaproponowanie pracownikowi komisji odcinków przy pomocy interaktywnego narzędzia mapy bądź spisu odcinków punktowanych w formie tekstowej.
%   \item [Pre-conditions] Użytkownik zalogowany jako przodownik kliknął na przycisk “Zaproponuj odcinek” znajdujący się w menu.
%   \item [Post-conditions] Zatwierdzony odcinek został poprawnie zaproponowany pracownikom komisji.
%   \item [Main scenario] \begin{enumerate}[noitemsep]
%     \item [1] System wyświetla użytkownikowi formularz zaproponowania nowego odcinka.
%     \item [2] Użytkownik wybiera punkt początkowy i końcowy z listy rozwijanej.
%     \item [3] Użytkownik wybiera z listy rozwijanej grupę górską, do której należy odcinek.
%     \item [4] Użytkownik wpisuje długość i przewyższenie odcinka w pola formularza.
%     \item [5] System na podstawie długości i przewyższenia wyświetla obliczoną punktację za przebycie danego odcinka.
%     \item [6] Użytkownik klika przycisk “Zatwierdź propozycję”.
%     \item [7] System wyświetla komunikat o poprawnym zaproponowaniu odcinka.
%     \item [] Koniec scenariusza
%   \end{enumerate}
%   \item [Alternative scenario \#1] \begin{enumerate}[noitemsep]
%     \item [6a.1] Użytkownik klika przycisk “Odrzuć propozycję”.
%     \item [6a.2] Użytkownik wraca na stronę główną.
%     \item [] Koniec scenariusza
%   \end{enumerate}
%   \item [Exception \#1] \begin{enumerate}[noitemsep]
%     \item [4a.1] Użytkownik wprowadza liczbę niedodatnią w polu długości lub liczbę ujemną w polu przewyższenia.
%     \item [4a.2] System wyświetla komunikat obok pola formularza o niepoprawnych danych.
%     \item [] Powrót do kroku 4
%   \end{enumerate}
%   \item [Exception \#2] \begin{enumerate}[noitemsep]
%     \item [6b.1] Połączenie internetowe zostaje przerwane.
%     \item [6b.2] System wyświetla komunikat o zerwanym połączeniu i niepowodzeniu operacji modyfikowania spisu.
%     \item [] Powrót do kroku 6
%   \end{enumerate}
% \end{description}

\subsection{Activity diagrams}

\todo{diagramy aktywności dla scenariuszów}

% możliwe w tikz-uml (sequence diagrams)

\subsection{Sequence diagrams}

\todo{}

% możliwe w tikz-uml (state-transitions diagrams)

\section{System architecture}

\subsection{Logical architecture}

\todo{diagram pakietów, czyli wydzielenie modułów w projekcie --- widok i model,
gdzie widok podzielony jest na komponenty a model na moduły}

% możliwe w tikz-uml (component diagrams)

\subsection{Physical architecture}

\todo{użyte technologie i zwizualizowany stack}

% niemożliwe w tikz-uml

\todo{Git}
\todo{Rust \cite{klabnik-2018}}
\todo{nom \cite{couprie-2015}}
\todo{Svelte \cite{svelte-docs}}
\todo{Rollup}
\todo{WebAssembly}
\todo{pakiety npm i cargo?}

\todo{opis technologii}

\section{Class diagram}

\todo{Diagram ``klas''}

% możliwe w tikz-uml (class diagrams)

\section{Interface prototype}

\todo{obrazki}

\chapter{Implementation of the project}

\section{Software environment}

\subsection*{Visual Studio Code}

\todo{konfiguracja, rozszerzenia}

\subsection*{Git and GitHub}

\todo{w jaki sposób używam Gita, GitHuba, jak używam branchy, issues, PR,
projektów}

\subsection*{Cargo}

\todo{konfiguracja Cargo, Clippy}

\subsection*{npm}

\todo{}

\subsection*{Rollup}

\todo{}

\section{Business logic}

\subsection{Grammar definition}

% \begin{listing}[H]
%   \inputminted[fontsize=\small]{haskell}
%   {listings/ast.hs}
%   \caption{\todo{podpis}}
%   \label{lst:ast}
% \end{listing}

\todo{opis}

\subsection{Lexical analyser}

\todo{krótko o ``algorytmie'' tokenizacji}

\subsection{Syntactic analyser}

\todo{zdefiniowanie ważnych parserów dla EBNF}

\subsection{Left recursion handling}

\todo{przedstawienie algorytmu do usuwania lewej rekurencji i wyjaśnienie po co}

% \begin{algorithm}[H]
%   \SetAlgoLined
%   \KwResult{The result}
%   initialization\;
%   \While{condition}{
%     instructions\;
%     \eIf{condition}{
%       instruction1\;
%       instruction2\;
%     }{
%       instruction3\;
%     }
%   }
%   \caption{Name of the algorithm}
% \end{algorithm}

\subsection{Dependency graph reduction}

\todo{przedstawienie algorytmu do wyszukania reguły początkowej}

\subsection{Grammar processing}

\todo{opisanie sposobu na sprawdzenie czy wejście należy do języka generowanego
przez gramatykę}

\section{Command line application}

\todo{}

\section{Web-based application}

\subsection{Linking the business logic}

\todo{jak się kompiluje Rusta do WebAssembly, czyli wasm-pack}

\subsection{Text editor}

\todo{CodeMirror}

\subsection{Visualizations}

\todo{}

\chapter{Project quality study}

\section{Business logic testing}

\subsection{Unit testing}

\todo{cargo test}

\subsection{Integration testing}

\todo{}

\section{UI testing}

\todo{Jest}

\section{Benchmarking}

\todo{cargo bench}

\section{Auditing}

\todo{Google Lighthouse}

\section{Complexity analysis}

\todo{clippy}

\todo{liczba linii kodu}

\chapter{Deployment}

\section{GitHub Pages}

\todo{}

\section{Electron}

\todo{}

\chapter{Artifacts}

\section{Source code}

\todo{}

\section{Web application}

\todo{}

\section{Desktop application}

\todo{}

\section{Command-line tool}

\todo{}

\section{Documentation}

\todo{}

\chapter{User manual}

\section{System requirements}

\todo{}

\section{Installation guide}

\todo{}

\section{Usage guide}

\todo{}

\chapter{Summary}

\todo{}

\bibliography{bibliography.bib}

\listoffigures

\listoftables

\listoflistings

\begin{appendices}

\chapter{Modified specification} \label{ch:modified-spec}

\todo{}

\begin{listing}[H]
  \inputminted[fontsize=\small,frame=single,breaklines,linenos]
    {lexers/ebnf_lexer.py:EbnfLexer -x}{listings/specification.ebnf}
  \caption{Modified version of the EBNF language specification defined in
  \cite{iso-14977}}
  \label{lst:specification}
\end{listing}

\end{appendices}

\end{document}
